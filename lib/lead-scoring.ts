import { groq } from "@ai-sdk/groq"
import { generateText } from "ai"

export interface Lead {
  id: string
  name: string
  source: string
  portfolioSize: string
  contactInfo?: {
    email?: string
    website?: string
    phone?: string
  }
  domainCategories?: string[]
  rawData?: any
  score?: number
  status: "New" | "Contacted" | "Interested" | "Not Interested" | "Converted"
  lastActivity: string
  activities?: {
    date: string
    type: string
    notes: string
  }[]
}

export function calculateLeadScore(lead: Lead): number {
  let score = 0

  // Portfolio size scoring
  const portfolioSizeStr = lead.portfolioSize
  const portfolioSize = Number.parseInt(portfolioSizeStr.replace(/\D/g, ""))

  if (portfolioSize >= 1000) score += 40
  else if (portfolioSize >= 500) score += 30
  else if (portfolioSize >= 100) score += 20
  else score += 10

  // Source reliability scoring
  switch (lead.source) {
    case "Sedo":
    case "GoDaddy Auctions":
      score += 25
      break
    case "OpenSea":
      score += 20
      break
    case "Web Scraper":
      score += 15
      break
    case "Manual Entry":
      score += 30
      break
    default:
      score += 10
  }

  // Contact info completeness
  if (lead.contactInfo) {
    if (lead.contactInfo.email) score += 10
    if (lead.contactInfo.website) score += 5
    if (lead.contactInfo.phone) score += 10
  }

  // Domain categories relevance
  if (
    lead.domainCategories &&
    lead.domainCategories.some((cat) => ["crypto", "web3", "nft", "blockchain"].includes(cat.toLowerCase()))
  ) {
    score += 15
  }

  return Math.min(score, 100) // Cap at 100
}

export async function scoreLeadWithLlama(lead) {
  try {
    const { text } = await generateText({
      model: groq("llama-3.3-70b-versatile"),
      prompt: `
        <Thinking>
        Analyze this potential lead for a Web2/Web3 domain business:
        
        Lead Information:
        - Name: ${lead.name}
        - Portfolio Size: ${lead.portfolioSize}
        - Source: ${lead.source}
        - Domain Categories: ${lead.domainCategories?.join(", ") || "Unknown"}
        - Contact Info Completeness: ${getContactInfoCompleteness(lead)}
        
        Consider these factors:
        1. Portfolio size (larger is better)
        2. Domain categories (Web3/crypto/tech domains are high priority)
        3. Contact information completeness
        4. Source reliability
        
        Calculate a score from 0-100 based on how valuable this lead is.
        </Thinking>
        
        <answer>
        {
          "score": 85,
          "reasoning": "This lead has a large portfolio of over 500 domains with a focus on tech and crypto categories. The contact information is complete, making outreach straightforward."
        }
        </answer>
      `,
      temperature: 0.2,
    })

    try {
      const result = JSON.parse(text)
      return {
        score: result.score,
        reasoning: result.reasoning,
      }
    } catch (e) {
      console.error("Failed to parse Llama response:", e)
      return { score: 50, reasoning: "Fallback score due to parsing error" }
    }
  } catch (error) {
    console.error("Llama scoring failed:", error)
    // Fallback to rule-based scoring
    return {
      score: calculateRuleBasedScore(lead),
      reasoning: "Generated by fallback rule-based system",
    }
  }
}

// Fallback rule-based scoring function
function calculateRuleBasedScore(lead) {
  let score = 0

  // Portfolio size scoring
  const portfolioSize = extractPortfolioSize(lead.portfolioSize)
  if (portfolioSize > 1000) score += 40
  else if (portfolioSize > 500) score += 30
  else if (portfolioSize > 100) score += 20
  else score += 10

  // Add other scoring factors...

  return Math.min(score, 100)
}

function getContactInfoCompleteness(lead) {
  if (!lead.contactInfo) return "None"

  const { email, website, phone } = lead.contactInfo
  const fields = [email, website, phone].filter(Boolean).length

  if (fields === 3) return "Complete"
  if (fields > 0) return "Partial"
  return "None"
}

function extractPortfolioSize(sizeString) {
  const match = sizeString.match(/(\d+)/)
  return match ? Number.parseInt(match[1]) : 0
}

